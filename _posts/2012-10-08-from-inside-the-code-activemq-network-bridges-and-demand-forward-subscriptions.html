---
layout: post
title: 'From inside the code: ActiveMQ Network Bridges and Demand Forward Subscriptions'
date: 2012-10-08 07:39:52.000000000 -07:00
categories: [activemq]
tags: [how-it-works, activemq, network-of-broker]
---
<p>I've written previously about <a href="http://www.christianposta.com/blog/?p=242">ActiveMQ Network Connectors</a> as a way to help describe some of the responsibilities of the classes that are involved with configuring a network of brokers for <a href="http://activemq.apache.org">ActiveMQ</a>. I recently had to dive back into that section of the code and found that blog post invaluable to help recall things about network connectors that I wouldn't otherwise retain in memory. Since it was so helpful to me, I'd like to continue on with how the network bridges and demand-forwarding subscriptions work. </p>
<p>Hopefully this information will be helpful to others that are interested in knowing more about what goes on under the covers, or to those contributing to the <a href="http://activemq.apache.org">ActiveMQ</a> project and are going to dig around in that area of the code.</p>
<p>This entry keeps it closer to the code details. If you are interested in viewing this from a little higher level, my colleague Jakub Korab <a href="http://www.jakubkorab.net/2011/11/understanding-activemq-broker-networks.html">has an excellent post with great diagrams</a>that explain broker networks.</p>
<p>So recall briefly from the last blog that a Network Connector can be defined like this the configuration:</p>
<p>[xml]<br />
&lt;networkConnector uri=&quot;static://(tcp://localhost:61626,tcp://localhost:61627)&quot; /&gt;<br />
[/xml]</p>
<p>The DiscoveryAgent associated with the NetworkConnector will initiate setting up a bridge for each transport URI specified in the <em>uri</em> attribute of the <code>networkConnector</code> This means if you're expecting multiple URIs to act as master/slave URIs, then the connector will try to establish a bridge to both the master and slave <em>always</em>. This is most likely not what you want (ie, you want to connect to the master only). An alternative would be to wrap the URIs in a <a href="http://activemq.2283324.n4.nabble.com/jira-Created-AMQ-3564-new-masterslave-discovery-agent-for-networkConnector-to-simplify-master-slave-n-td3936666.html">masterslave:</a> transport to identify the URIs appropriately and connect to the master at first and only to the slave if the master fails.</p>
<p>Note, that for each URI, if a bridge ends up being destroyed because of an unanticipated exception, the bridge will always attempt to be re-created.</p>
<h3>What does a network bridge do?</h3>
<p>So what exactly does the bridge do? Well, a network bridge basically coordinates with the local broker (using a VMTransport) and the remote broker (using a Transport specified by the URI: TCP/SSL/HTTP, etc) and implements the "Demand Forwarding" behavior expected from the network of brokers. Let's look step by step how that happens.</p>
<h3>How a bridge works</h3>
<p>In the DiscoveryNetworkConnector#onServiceAdd method, you can clearly see where the transports are being created. One for the local broker, and one to the remote broker. Next, you'll see the bridge created, passing in the transports, and finally the bridge started.</p>
<p>When the bridge starts, it first sets up TransportListeners for both local and remote transports before starting the transports. This allows the bridge to service commands from the local and remote brokers and act accordingly. This is sort of what the TransportConnection class does for normal broker clients. The meat of the code for the network bridges is in <code>org.apache.activemq.network.DemandForwardingBridgeSupport.java</code> So when our transports consume from advisories, send messages, or ack messages, it's doing so using the ActiveMQ command objects directly.</p>
<p>Once the listeners are set up, the transports (that were created in DiscoveryNetworkConnector#onServiceAdd) are then started, which will kick off the normal exchange of command objects: for the remote broker, a wire-format negotiation takes place to determine what version of OpenWire to use (for the TCP/SSL connections) and then the remote broker sends a BrokerInfo command to the bridge's remote transport to identify itself. For the local transport, there is no wire-format negotiation. The local broker sends a BrokerInfo command to the local transport to identify itself.</p>
<p>Now we have the transports configured to listen for incoming commands and we have them started and talking with the respective brokers (local and remote). Now the key to the <em>Demand Forwarding</em> takes place. We start the bridge to the remote broker. This part is responsible for determining what the "demand" is from consumers on other brokers. Gary Tully has an <a href="http://blog.garytully.com">excellent blog post</a> about the exact terminology of the Bridge, Demand, and Forwarding that explains in plain language the role of each of the components. When a consumer on a remote broker subscribes to a destination that exists on our local broker, we consider that consumer to have "demand" for the messages on the destination on our local broker. For example, consider a local broker bridged to a remote broker: if I have a producer to a destination named "foo" on the local broker, and a consumer attaches to the remote broker and wants to establish a subscription to a destination named "foo", the remote broker will do so without worry. But there are no producers to "foo" on the remote broker, only the one on the local broker. When the bridge is set up, it will see that there is a remote demand (consumer) for messages on "foo" so it will <em>forward</em> messages for the "foo" destination to the remote broker. There we have "demand" (the consumer on the remote broker) and <em>forwarding</em> the message thus: Demand Forwarding.</p>
<p>So how does the local broker determine demand?</p>
<p>In the <code>DemandForwardingBridgeSupport#startRemoteBridge</code> we set up a connection, session, and consumer to the remote broker. The consumer is set to consume from a <a href="http://activemq.apache.org/advisory-message.html">Advisory Topic</a> named <code>ActiveMQ.Advisory.Consumer</code> on the remote broker. If the <code>networkConnector</code> is set to bridge temp destinations, then the consumer is also going to listen to advisory topics named <code>ActiveMQ.Advisory.TempQueue</code> and <code>ActiveMQ.Advisory.TempQueue</code>. These topics notify listeners of new consumers that establish a subscription to a destination on the remote broker.</p>
<h3>Setting up the demand</h3>
<p>So now we see that bridge on our local broker is listening to the advisory topics on the remote broker. But how is the "demand" set up?</p>
<p>When we receive an advisory message from the remote broker, we check to see what kind of command was the underlying cause of the advisory. If the underlying cause was a ConsumerInfo (consumer subscription), then we know there is a consumer on the remote broker interested in having messages forwarded to it, so we set up a "Demand Subscription."</p>
<h3>Forwarding messages</h3>
<p>What happens is the same ConsumerInfo command that was used to create a subscription on the remote broker is altered a little bit (given a new consumerId, sessionId, etc) and passed on to the local broker. This creates a corresponding subscription on the local broker for the specified destination. Now when messages are sent to the destination on the local broker, the local destination will have a subscription. The local broker will dispatch the message to the subscription (which is effectively the bridge that created the subscription) and the bridge will now forward it on to the remote broker. You can see the bridge forward the message from the local broker to the remote broker in DemandForwardingBridgeSupport#serviceLocalCommand in the conditional that checks that its a <code>MessageDispatch</code>.</p>
<p>The DemandSubscription held by the bridge objects will always correlate with a subscription on the local broker, and one on the remote broker. An important key to the DemandSubscription objects is the consumerIds. The <code>localInfo</code> refers to the consumer with the consumerId associated with the subscription on the local broker. The <code>remoteInfo</code> will refer to the consumer with the consumerId associated with the subscription on the remote broker.</p>
<p>So those are the basics. I could have written a bunch more about the different things that pop up in different configurations, duplex bridges, more complex networks, etc, etc, but I think this is enough to jog my memory later or to help others understand how the demand forwarding works. Plus, I've already spent enough time writing, now it's time to hack on <a href="http://activemq.apache.org/apollo/index.html">Apollo</a> JIRAs.</p>
<p>If you have specific questions, please let me know!</p>
