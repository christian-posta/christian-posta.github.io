---
layout: post
title: Programming without a call stack?
date: 2012-02-08 16:30:06.000000000 -07:00
categories: []
tags: [programming]
comments: true
---
<p>Over the weekend I read an excellent essay called <a href="http://eaipatterns.com/docs/EDA.pdf" target="_blank">“Programming Without a Call Stack - Event-driven Architectures”</a> by <a href="http://www.enterpriseintegrationpatterns.com/" target="_blank">Gregor Hohpe</a> that does an excellent job of explaining how an event-driven architecture (EDA) differs drastically from the traditional, procedural, call-stack style of programming that most are used to and comfortable with. The EDA approach is nothing new: it’s employed in many embedded systems, high-throughput web companies (<a href="http://highscalability.com/amazon-architecture" target="_blank">think Amazon</a>), and is the backbone of creating highly concurrent applications (the <a href="http://en.wikipedia.org/wiki/Actor_model" target="_blank">Actor model</a> from Erlang/Scala?).</p>
<p>Gregor starts by describing what an EDA would look like and describes some of the characteristics EDAs usually exhibit. The focus of an EDA is to drastically reduce coupling and assumptions between the individual components so that the components can vary independently, so that they system as a whole can achieve great throughput and concurrency, and finally so that system state can be replayed, recreated, and analyzed in ways that cannot be done (or would be very difficult) with traditional architectural styles. The primary philosophy shift between the call-stack approach and the EDA approach is in responsibility and interaction. The responsibility of “knowing what to do” is shifted from the caller to callee and the only interaction is with fine-grained asynchronous messages passed in one direction. Compare this to the call-stack model, where one thread of execution delegates to sub routines, waits for a response, then takes that data and operates on it or calls other sub routines. There is always one trace of execution, the sub routines are always fast, and the location of the subroutines is known at compile/build time. The responsibility in the call-stack approach is on the caller and the interactions depend on a context, synchronization with the calling thread, and knowing exactly how and what to call next.</p>
<p>Gregor also puts forth that doing EDA properly, although elegant when done correctly, is not easy and without proper tooling and visualization of the composed system, debugging and verifying that the components were put together properly can be very difficult.</p>
<p>Gregor gave a talk on this topic during the <a href="http://www.oopsla.org/2005" target="_blank">OOPSLA 2005</a>. I could not find a video archive of this talk specifically, but the essay is posted as a PDF at this website here: <a href="http://eaipatterns.com/docs/EDA.pdf" target="_blank">http://eaipatterns.com/docs/EDA.pdf</a></p>
<p>If anyone has a link to the video (if there is one?), I would be grateful if you could provide it.</p>
