---
layout: post
title: 'From inside the code: Camel RouteBuilder and Java DSL'
date: 2012-05-21 18:41:42.000000000 -07:00
categories:
- Camel
tags: [how-it-works, camel, DSL, routing]
---
<p>Recently got back from <a href="http://www.camelone.com/">Camel One</a> and now it's time to get back to business. One topic of discussion I wanted to go over quickly is the Camel route builders and the DSL around them. Ever wonder how and why certain Java DSL methods are available in the route builder? For example, to begin a route, you must specify a consumer endpoint which is either push-driven or poll-driven and introduces an Exchange to your camel route. To do this, you use the <code>from()</code> DSL method. Which makes sense within the rest of the route, because you're getting messages/exchanges <strong>from</strong> an endpoint and then starting your route. But for some of you experienced Camel developers, you'll wonder what exactly you can do after you've created your consumer with the <code>from()</code> method. Well to fully understand that, you must understand a little about how the RouteBuilder API works.</p>
<p>When you define a route with the Java DSL, you start by creating a new class that extends from the <em>org.apache.camel.builder.RouteBuilder</em> abstract class and then override the <em>configure()</em> method and implement a route with the DSL. You start the route with the <em>from()</em> method mentioned above, but where does that method come from? Consider the following UML diagram:</p>
<p><img src="/images/routebuilder2.png" alt="class diagram of route builder" /></p>
<p>When you extend the <em>RouteBuilder</em> class, you inherit all of its methods as well as the <em>BuilderSupport</em> methods. The <em>RouteBuilder</em> class is where the <em>from()</em> method lives as well as a couple other methods that are "global" to the route such as <em>onException()</em>, <em>errorHandler(...)</em>, <em>intercept()</em> etc. The methods in this class are intended to begin a route or configure its exception and error handling. <em>RouteBuilder</em>'s parent class, <em>BuilderSupport</em> provides a bunch of methods for building expressions with the ValueBuilder (for body or headers), XPathBuilder (for creating xpath-compliant expressions), SimpleBuilder (camel's built-in expression language), ErrorHandlerBuilder, DeadLetterChannelBuilder and a couple others. These methods can be used throughout the route wherever the appropriate expression is expected. This is why, for example, the <em>simple()</em> method or the <em>xpath()</em> method is available within other DSL methods. See the full list of methods for each class below. Note the methods for each class are cohesive to the class -- meaning they all belong to their respective class for a reason. Those that belong to <em>BuilderSupport</em> are specifically to add commonly used expressions anywhere within the route (thus <em>supporting</em> the building of a route). The methods belonging to <em>RouteBuilder</em> are specific to beginning a route and configuring the global exception/error handling for that route.</p>
<p><img src="/images/routebuilder.png" alt="class diagram of route builder with methods" /></p>
<p>When you call the <em>from()</em> DSL method, a <em>RouteDefinition</em> is created and added to the RouteBuilder's route group (so the builder is aware of the route and knows where it is), then returned. That means when you call <em>from()</em> it returns a <em>RouteDefinition</em> object upon which you can call whatever other DSL methods that make up the route. So this <em>RouteDefinition</em> class must be pretty important, right?</p>
<p><img src="/images/routedef.png" alt="route definition class hierarchy" /></p>
<p>Yes, it is important. <em>RouteDefinition</em> is a concrete implementation that represents the beginning of a route definition and is where you begin to add the next steps of your route. In camel, every step of the camel route is represented as a "processor." Out of the box the DSL provides many implementations of endpoints and EIPs to string together your route. Take a look at the class hierarchy. The <em>OptionalIdentifiedDefinition</em> abstract class is around mostly for adding an identifier and description to your route. Not very interesting, but good to know. The <em>ProcessorDefinition</em> class, however, is very interesting as it's the superclass for a RouteDefinition as well as almost every other specialized route definition. This base class is the reason why you have access to the EIP DSL once you've created your consumer endpoint with <em>from()</em>. Take a look at its methods (note, kinda long list):</p>
<p><img src="/images/routedef1-m.png" alt="processor def class hierarchy with methods" /></p>
<p>As you can see, just about all of the DSL methods are on this class. This class also happens to be the base class for other route definitions so these methods are always available in your route. What do I mean by other route definitions? Well, consider route:</p>
<p>[java]<br />
from(&quot;direct:input&quot;).choice()<br />
[/java]</p>
<p>This route starts the route by creating a consumer with the "direct:input" component. Once the <em>from</em> method is called, it returns a <em>RouteDefinition</em> which is a subclass of <em>ProcessorDefinition</em> If you look above at the methods for <em>ProcessorDefinition</em> you'll see that among the other EIP methods, <em>choice()</em> EIP method is available which represents a content-based router. When you call the <em>choice()</em> method, a new definition is returned: a <em>ChoiceDefinition</em>. A <em>ChoiceDefinition</em> is a more specific type of definition that supports the semantics around the content-based router (such as the <em>when</em> and <em>otherwise</em> DSL methods). But since the <em>ChoiceDefinition</em> also inherits from the <em>ProcessorDefinition</em> you can continue your route by calling other EIPs or processor methods:</p>
<p><img src="/images/choicedef.png" alt="choice def class hierarchy with methods" /></p>
<p>What happens when you call <em>when()</em> on the ChoiceDefinition without any parameters (the <em>when</em> method expects an expression)? Note that it returns an expression object which allows you to build your expression inline with the DSL, but when you're done with the expression it will return the <em>ChoiceDefinition</em> object again to allow you to continue your DSL. To make this clear, here is the signature of the <em>when</em> method from the <em>ChoiceDefinition</em> class:</p>
<p>[java]<br />
public ExpressionClause&lt;ChoiceDefinition&gt; when()<br />
[/java]</p>
<p>What this means is that when you get the <em>ExpressionClause</em> object returned from your call to <em>when</em> you can call expression methods (see <a href="http://camel.apache.org/maven/camel-2.8.0/camel-core/apidocs/org/apache/camel/builder/ExpressionClause.html">the definition of ExpressionClause</a> in the API Docs) to build the predicate for your "when" condition of the content based router. Once you've called your expression, you will be returned a <em>ChoiceDefinition</em> (which is the generic type passed to the <em>ExpressionClause</em> class so it knows what to return) and continue your content based router or start a different EIP or processor.</p>
<p>I realize some of these details might be too low level for some people. It is not meant to be a step-by-step guide for using Camel, but more of an overview of the API to help conceptualize why some of the DSL methods are available (or not available) so you can become more comfortable with the DSL.</p>
<p>To recap: The RouteBuilder builds a RouteDefinition which inherits from a ProcessorDefinition. With the ProcessorDefinition you can string together many EIPs and processors some of which return their own specific definitions classes. But since the definition classes inherit from the ProcessorDefinition, you can continue building the route even after using the specific definition classes. When expressions are mixed in the with route, you can expect the expression methods to return whatever definition class that was used before the expression.</p>
<p>If someone has anything to add, or comments/questions, I am eager to hear.</p>
