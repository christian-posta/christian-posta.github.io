---
layout: post
title: 'From inside the code: ActiveMQ Network Connectors'
date: 2012-05-02 00:44:33.000000000 -07:00
categories: [activemq]
tags: [activemq, newtork-of-brokers, how-it-works]
---
<p>This post is more for me and any ActiveMQ contributors that may be interested in how the Network Connectors work for ActiveMQ. I recently spent some time looking at the code and thought that it would be good to draw up some quick diagrams to help me remember what I learned and help to identify where to debug in the future if there are issues I am researching. If I make a mistake and you'd like to add clarification, please do so in the comments.</p>
<p>First, you set up your network connectors by configuring them in the ActiveMQ configuration file. This configuration gets mapped to the corresponding ActiveMQ beans using the xbean library for which I have <a href="http://www.christianposta.com/blog/?p=111">a separate blog post</a> which explains exactly how this is done. To specify network connectors, you add the <code>&lt;networkConnectors/&gt;</code> element to your configuration file and add a <code>&lt;networkConnector/&gt;</code>, <code>&lt;multicastNetworkConnector/&gt;</code>, or <code>&lt;ldapNetworkConnector/&gt;</code>. These three different types of network connectors can be used to establish a network of brokers with <code>&lt;networkConnector/&gt;</code> being most common. Here's how the three map to Java classes:</p>
<p><code>&lt;networkConnector/&gt;</code> maps to org.apache.activemq.network.DiscoveryNetworkConnector<br />
<code>&lt;multicastNetworkConnector/&gt;</code> maps to org.apache.activemq.network.MulticastNetworkConnector<br />
<code>&lt;ldapNetworkConnector/&gt;</code> maps to org.apache.activemq.network.LdapNetworkConnector</p>
<p>Each of those inherit from the <code>org.apache.activemq.network.NetworkConnector</code> super type as depicted in this diagram:</p>
<p><img src="/images/networkconnector.png" alt="Network Connectors Diagram" /></p>
<p>So when you have a configuration like this:</p>
<p>[xml]<br />
&lt;networkConnector uri=&quot;static://(tcp://localhost:61626,tcp://localhost:61627)&quot; /&gt;<br />
[/xml]</p>
<p>a new DiscoverNetworkConnector will be configured, instantiated, and added as a connector to the BrokerService (which is the main class for where a lot of the ActiveMQ broker details is handled). While the DiscoverNetworkConnector is being assembled from the configuration, the URI that you specify is used to create a DiscoveryAgent. The discover agent is in charge of assembling the connection and handling failover events that are packaged as DiscoverEvents. Determining which DiscoverAgent is picked depends on the DiscoverAgentFactory and the URI specified. In the case of "static", the SimpleDiscoverAgent is used. Each URI in the list of possible URIs are treated differently and are assigned their own Transport (more on this in a sec). Which means, for each URI you list, a new socket will be established and the broker will attempt to establish a network connector over each of the sockets. You may be wondering how to best implement failover then? In the case described above, you will have multiple connections, and if one of those connections is to a slave that isn't listening, you will see that the connection fails and the discover agent tries to establish the connection again. This could go on infinitely which consumes resources. Another approach is to use just one URI for the static discover agent that utilizes the failover() logic:</p>
<p>[xml]<br />
&lt;networkConnector uri=&quot;static:failover:(tcp://localhost:61626,tcp://localhost:61627)&quot; /&gt;<br />
[/xml]</p>
<p>In this case, only one transport will be created, and the failover logic will wrap it and know about both URIs. If one is not available, it won't keep retrying needlessly. Instead it will connect to whichever one it can and only reconnect to the failover URL if the current connection goes down. Note this approach had a bug in it before ActiveMQ version 5.5.1.-fuse-00-06.</p>
<p>The discover agent is in charge of creating the bridge, but it delegates that responsibility to a DiscoverListener. In the example from above, the DiscoverListener interface is implemented by the DiscoverNetworkConnector.onServiceAdd() method.</p>
<p>To establish the bridge, a transport is opened up for both the local broker (using VM) and the remote broker (using the specified protocol, in this case TCP). Once the local and remote transports are created, the bridge can be assembled in the DiscoverNetworkConnector.createBridge(...) method. This method uses the Factory pattern again to find which bridge to use.</p>
<p>The possible bridge implementations are shown below:</p>
<p><img src="/images/networkbridge.png" alt="Network Bridge Implementations Diagram" /></p>
<p>By default, with conduitSubscriptions=true, the DurableConduitBridge is used. Conduit subscriptions establish a single flow of messages to a remote broker to reduce duplicates that can happen when remote topics have multiple consumers. This works great by default, but if you want to load balance your messages across <em>all</em> consumers, then you will want to set conduit subscriptions to false (see <a href="http://fusesource.com/docs/esb/4.3/amq_clustering/Networks-Connectors.html">the documentation for conduit subscriptions</a> at <a href="http://www.fusesource.com/">FuseSource</a>'s documentation on <a href="http://fusesource.com/products/enterprise-activemq/">Fuse Message Broker</a>). When set to false, the DemandForwardingBridge is used. Once the bridge is assembled, it is configured in the NetworkConnector.configureBridge(...) method.</p>
<p>Once everything is assembled and configured on the bridge, it's then started. Once it's started, it begins sending broker Command objects to the remote broker to identify itself, set up a session, and demand consumer info from it. This is in the DemandForwardingBridgeSupport.startRemoteBridge() super class method as seen from the diagram.</p>
<p>If you're debugging errors with the network connectors, hopefully this helps identify possible locations for where errors can take place.</p>
